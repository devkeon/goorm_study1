# 객체 지향 프로그래밍 (Object-Oriented Programming, OOP)


## 들어가기에 앞서..
프로그래밍 패러다임에 대해 알아볼 필요가 있다. 이유는? 
우리가 사용하는 프로그래밍 언어들은 서로 다른 프로그래밍 패러다임을 지원한다.
사용하는 언어가 지원하는 프로그래밍 패러다임도 모르고 쓰는 바보는 없을 것이다.

### 프로그래밍 패러다임이란?

- 프로그래밍 패러다임은 프로그래머로 하여금 프로그래밍의 관점을 갖게 해주고 결정하는 역할을 한다.
- 쉽게 말해서 프로그래머가 어떻게 생각하고 어떻게 코드를 짤 지 관점을 갖게 해준다.

쉬운 예를 들어, 우리가 살펴볼 객체 지향 프로그래밍은 프로그래머로 하여금 객체로서의 관점을 갖게 해준다.

여러 프로그래밍 패러다임이 있는데, 대표적으로 절차 지향 프로그래밍의 C언어, 함수형 프로그래밍인 LISP 등
여러 언어들이 프로그래밍 패러다임을 지원하는 것을 볼 수 있다.

이러한 프로그래밍 패러다임이 발전해온 바를 조금 살펴보자.

#### 순차적 프로그래밍
아마 수업 시간에도 스쳐지나가며 배웠을 goto문을 사용한다. goto문을 사용하면 흔히들 얘기하는 스파게티 코드가 되기 쉽상이다.
여기 갔다가 저기 갔다가..이러한 단점을 개선한 것이 절차적 프로그래밍이다.

#### 절차적 프로그래밍(Procedrual Programming)
절차적 프로그래밍에서는 이러한 goto문의 사용을 제약한다. 그렇다보니 스파게티 코드가 될 확률을 줄여주고 프로시저를 사용해서
프로그래밍 한다. 이름이 절차적 프로그래밍이라 해서 절차적으로 프로그래밍 한다는 것이 아니라 프로시저 단위로 본다.

그렇다면 위의 프로그래밍 패러다임들보다 비교적 최근에 나온 객체 지향 프로그래밍은 무엇일까?


## 객체 지향 프로그래밍이란?

객체를 하나의 레고 조각이라 보고 레고를 조립하는 것이라고 생각하면 되겠다. 우리가 한 부분의 기능을 바꾸고자 하면 레고 조각만 갈아 끼우면 된다.
데이터와 그 객체에 맞는 기능이 객체에 함께 담겨있다고 보면 된다. 그리고 이러한 객체들을 조립하여 만드는 프로그래밍을 객체 지향 프로그래밍이라고 한다.
이 패러다임을 지원하는 언어는 대표적으로 Java, Python, C++ 등이 있다.

### 객체 지향 프로그래밍의 장점
- 프로그램을 보다 유연하 변경이 용이하게 만든다.
- 코드의 재사용을 통해 코드가 더욱 간결해질 수 있다.
- 실제 세상의 상호관계를 프로그래밍에 구현하고자 하였기 때문에 보다 직관적인 코드 작성이 가능하다. (진짜 이런지는 사실 잘 모르겠음)

## 객체 지향 프로그래밍의 특징
아마 프로그래밍을 배운지 얼마 안 된 사람도 이 4가지를 들어봤을 것이다. 그럼에도 감이 안잡혔던 사람들이 많았을 것 같은데 제대로 짚고 넘어가보자.

<br />

### 캡슐화
- 데이터와 기능 하나의 단위로 묶는다.
- 객체가 내부적으로 어떻게 구현되어 있는지 감춘다.
- 느슨한 결합을 통해 한 부분만 수정하기 용이하다.

>조금 추가해서 설명하자면 우리가 핸드폰을 사용하면서 핸드폰의 내부가 실제로 어떻게 구현되어있는지 잘 모른다. 하지만 사용에는 문제가 없다.
심지어 기능이 업그레이드 되어 핸드폰이 새로 출시되어도 우리가 실제로는 어떻게 성능이 업그레이드 되었는지 모르고 사용할 수 있다.
만약 내부가 공개되어있다면 이는 곧 사용자 경험으로 하여금 떨어질 수 있다. 

![img](https://www.particlemag.com/wp-content/uploads/2022/12/1220-1-1024x682.jpg)

~~엥..?~~

<br />

### 추상화
- 객체의 세부 사항들은 숨기고 본질만 표현하는 것이다.
- 공통적인 본질들만 묶어서 하나의 객체로 묶는 것이다.

>우리가 운전을 하면 자동차의 종류가 포르쉐건, 페라리건 엑셀을 밟으면 앞으로 간다는 것과 브레이크는 멈추는 것이라는 자동차의 본질은 바뀌지 않기 때문에
운전이 가능하다. 포르쉐가 몇 마력을 내는지, 페라리에는 무슨 기능이 있는지와 상관없이 자동차의 본질은 변하지 않고 공통적이기 때문이다.
이렇게 운전을 하는 것은 사용자이고 자동차가 추상화된 객체라고 생각하면 이해가 될 것이다.

![img](https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%B6%94%EC%83%81%ED%99%94.png?w=893&ssl=1)
<br />
<br />

### 상속
- 상속은 부모 객체로부터 자식 객체가 물려 받는 말 그대로 상속이다.
- 위에서 말했던 객체 지향 프로그래밍의 장점 중 하나인 재사용을 실현해주는 특징이다.
- 추상화된 객체로부터 상속을 받아 기능을 추가하여 객체를 만들 수 있는데 이 때, 코드의 재사용성이 증가한다.

![img_2](https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%83%81%EC%86%8D.png?w=893&ssl=1)

### 다형성
- 객체 지향의 핵심이라고 생각한다.
- 상속과 함께 올 때 가장 강력하며 부모 객체를 상속받아 자식 객체가 오버라이딩해서 자신에 맞게 활용하는 것을 의미한다.
- 말 그대로 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질이다.

>위에서 봤던 차의 비유에서 자동차라는 추상화 객체를 상속받아 세부적인 기능을 구현해 페라리를 만들 수도 있고 포르쉐를 만들 수도 있는 것과 같다.

![img_3.png](https://velog.velcdn.com/images%2Fhyun6ik%2Fpost%2F754b49f8-44e8-49e7-9240-cc35062df754%2Fimage.png)
~~김영한님 강의에서 확인할 수 있습니다.~~


뭔가 2% 빠진것 같은데?

## 다형성의 본질에 대해 살펴보자면..
- 보통 객체는 클라이언트-서버의 관계를 갖는다.
- 클라이언트 코드를 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있다.
- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.

개발자는 코드가 이해가 더 쉽죠?

```java
Vehicle car = new Car();
//위 코드를 아래로 변경시키려면 클라이언트 코드를 변경해야함.
Vehicle car = new Porsche();
```
그래서 위와 같은 문제점을 편하게 해결하기 위해 스프링을 사용한다고 하는데..일단 스프링에 대한 글이 아니니 넘어가겠습니다.

이제 이러한 객체 지향을 어떻게 설계해야하는지 알아보겠다.


## 객체 지향 설계 과정

- 제공해야 할 기능을 찾고 세분화한다. 그리고 그 기능을 알맞은 객체에 할당한다.
- 기능을 구현하는데 필요한 데이터를 객체에 추가한다.
- 그 데이터를 이용하는 기능을 넣는다.
- 기능은 최대한 캡슐화하여 구현한다.
- 객체 간에 어떻게 메소드 요청을 주고받을지 결정한다.

## 객체 지향 설계 원칙
![img_4](https://velog.velcdn.com/images/haero_kim/post/169ef81a-0c8c-4241-a73a-135d5b67ffea/1_XOMTPWTpDLypkp079p9XXg.png)

우리 선배 개발자들은 객체 지향 설계를 잘하라고 원칙을 만들어두셨습니다. 사실 원칙으로 객체 지향 프로그래밍에 들어가기에 앞서 알아야 할 것들이지만
역설적이게도 제일 까다롭고 어려운 부분이다. 하나씩 살펴보겠습니다.


### 단일 책임 원칙 (Single Responsibility Principle, SRP)
- 단일 책임 원칙이란 클래스는 **단 하나의** 책임만 가져야 한다는 원칙이다.
- 책임이란 하나의 기능을 의미한다고 보면 된다. 만약 하나의 클래스에 기능이 여러 개라면 유기적으로 얽혀있을 가능성이 크기 때문에 유지 보수에 비용이 많이 든다.
- 사실 하나의 책임이라는 범위가 상당히 모호하므로 위에서 말한 것과 같이 변경에 따른 파급효과가 적으면 잘 따랐다고 본다.

### 개방-폐쇄의 원칙 (Open/Closed Principle, OCP)
- 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야한다.
- 기능 추가가 필요하다면 클래스 확장을 통해 손쉽게 구현하면서 확장에 따른 클래스 수정은 최소화 하는 원칙이다.
- 이걸 어케? 다형성을 생각해보면 된다. 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙이다.
- 확장에 열려있다: 유연하게 코드를 추가하여 기능 확장 가능
- 변경에 닫혀있다: 객체를 직접적으로 수정을 제한함
- 추상화 사용을 통한 관계 구축을 권장한다는 뜻이다.

### 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
- 자식 객체는 언제나 부모 객체로 교체할 수 있다는 원칙. (부모 객체를 자식으로 치환해도 같은 기능을 한다는 원칙)
- 다형성 원리를 이용하기 위한 원칙이라고 생각하면 된다.
- 한마디로 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 의미이다.

### 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)
- 인터페이스를 각각 사용에 맞게 잘게 분리해야한다는 원칙
- SRP는 클래스의 단일 책임을 강조한다면 ISP는 인터페이스의 단일 책임을 강조한다.
- 하나의 범용 인터페이스보다 여러 개의 인터페이스가 더 나음.
- 인터페이스가 더 명확해지고 대체 가능성이 높아진다. -> 유지 보수가 좋아지겠죠?
- 다만 주의할 점은 한 번 인터페이스를 구성하면 수정사항에 의해 인터페이스를 다시 분리하는 행위는 삼가해야한다.

### 의존 역전 원칙 (Dependency Inversion Principle, DIP)
- '추상화에 의존해야지 구체화에 의존하지 마라'
- 말그대로 참조해야 할 클래스가 아닌 그 대상의 상위 요소 (인터페이스 혹은 추상 클래스)에 참조하라는 원칙이다.
- 의존 관계를 맺을 때 변화하기 쉬운 것보다는 변화하기 어려운, 역할에 의존하라는 의미이다. (만약 구현체에 의존하면 수정이 생기면 굉장히 복잡해지겠죠?)

>고수준 모듈은 저수준 모듈에 의존하면 안된다는 의미이다.
> - 고수준 모듈: 실제 사용과 근접해 있는 것, 모듈의 본질적인 기능과 책임을 나타낸 것.
> - 저수준 모듈: 이러한 고수준 모듈의 기능을 구현하기 위한 하위 기능의 실제 구현

이게 무슨 소리인가 싶을 텐데 코드로 살펴보자.

```java
public class DeliveryService {
    public void delivery() {
        rider.deliver();
    }
    public void payment() {
        toss.credit();
    }
}
```
이러한 배달 서비스를 하는 고수준 모듈이 있다고 치자. 위에서 배달 서비스는 저수준 모듈인 rider와 toss를 의존하고 있다.

이런 상황이라면, 만약 rider가 아닌 드론이 배달해주고 공짜 이벤트를 한다면 아래와 같이 코드를 수정해야 할 것이다.

```java
public class DeliveryService {
    public void delivery() {
        dron.fly();
    }
    public void payment() {
        forFree.justGet();
    }
}
```
기능이 바뀌었다 고수준 모듈의 코드 또한 수정을 해야하는 복잡한 상황이 발생한다. 따라서 고수준 모듈에 배달과 결제 인터페이스를 두고
저수준 모듈이 고수준 모듈의 인터페이스를 의존하게 된다면 의존 관계가 역전될 것이다. 그러면 고수준 모듈의 변경을 최소화 해주면서 
저수준 모듈의 유연성이 높아지는데 이것이 바로 의존 역전의 법칙이다.

위와 같이 SOLID 원칙을 통해 객체 지향을 더욱 객체 지향 답게 구현할 수 있게 된다.

이러한 원칙들을 기억하며 즐거운 객체 지향 프로그래밍 되길 바랍니다.

참고자료:

인파, "객체 지향 설계의 다섯가지 원칙-S.O.L.I.D", Inpa Dev, 2022.11.11. 12:42, https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID

코드 스테이츠, "객체 지향 프로그래밍의 4가지 특 | 추상화, 상속, 다형성, 캡슐화", code blog, 2022.11.30. , https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95

김영한, "스프링 핵심 원리 - 기본편", 인프런, https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard

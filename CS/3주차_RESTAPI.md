## REST API

<br>
쉽게 말해 REST API는 다음의 구성으로 이루어져있습니다.

<br>

<ul>
<li>자원(RESOURCE) - URI</li>
<li>행위(Verb) - HTTP METHOD ex) GET, PUT, DELETE, POST</li>
<li>표현(Representations)</li>
</ul>

>"REST는 효율적, 안정적이며 확장가능한 분산 시스템을 가져올 수 있는 소프트웨어 아키텍처 디자인 제약의 모음을 나타냅니다."

<br>

MDN <a href = "https://developer.mozilla.org/ko/docs/Glossary/REST">REST페이지</a>에서 REST의 기본 개념은 리소스라고 설명합니다. 리소스의 예로는 잘 인식되고 언어에 상과없이, 안정적이고 표준화된 클라이언트/서버 상호작용을 통해 전송되는 문서를 들 수 있습니다. 여기서 말하는 조건에 해당하는 리소스 파일은 우리가 사용해본 JSON 문서 파일 등이 있다는 걸 알 수 있습니다.

<br>

그리고 이러한 제약조건을 준수하면 RESTfu로 간주됩니다. 일반적으로 HTTP API는 모든 REST 제약 조건을 반드시 준수하지 않지만 RESTful API, RESTful 서비스 또는 REST 서비스라고도 합니다.

<br>

>REST란 무엇인가

<br>

1. 일관된 인터페이스

일관된 클라이언트와 서버 간의 인터페이스를 통해, 아키텍처를 단순화하고 결합 분리함으로써 각 부분이 독립적으로 발전할 수 있도록 합니다.

<br>

    1-1. 리소스 기반

        앞서 말했듯 REST의 기본 개념은 리소스입니다.
        개별 리소스는 URI(URL의 확장된 개념)을 사용하여 요청에서 식별됩니다. 이 리소스가 클라이언트에 반환되는 표현과 개념적으로 분리됩니다.
        예시로 서버는 데이터베이스 자체를 보내지 않고, 요청사항이나 서버의 구현에 따라 표현되는 데이터베이스 레코드를 담은 리소스를 반환하고,
        즉 클라이언트가 인식하는 표현과 개념의 형태의 리소스를 보낸다는 소리죠. 리소스의 형태는 HTML, XML 또는 JSON과 같은 데이터를 반환합니다.
        균일한 리소스 식별자

    1-2. 리소스 조작

        클라이언트가 리소스에 연결된 메타데이터를 포함하여 서버에서 해당 리소스를 수정하거나 삭제할 권한이 있어야 합니다.

    1-3. 데이터 자체를 설명해야합니다.

        각 메시지는 메시지를 처리하는 방법을 설명하는 충분한 정보를 포함합니다. 
        어떤 파서를 호출할 것인지 인터넷 미디어 유형으로 지정할 수 있도록 말이죠. 
        우리가 이전 Github Api의 주소를 가지고 여러 데이터들을 읽어올 수 있었던 이유가
        데이터가 데이터 자기자신을 충분히 설명하기 때문에 여러 데이터들을 읽어올 수 있도록 설계되어 있기 때문입니다.

    1-4. HATEOAS(Hypermedia As The Engine Of Application State)

        클라이언트는 본문 내용, 쿼리 문자열 매개변수 ,요청 헤더 및 요청 URI를 통해 상태를 전달합니다.
        서비스는 본문 내용, 응답코드 및 응답헤더를 통해 상태를 클라이언트에게 전달합니다.
        이것은 기술적으로 하이퍼미디어로 참조된다고 합니다.


2.  무상태(Stateless)

    >HTTP 프로토콜은 기본적으로 무상태이다

    REST 아키텍처에서 무상태는 서버가 이전의 모든 요청과 독립적으로 모든 클라이언트 요청을 완료하는 통신 방법을 나타냅니다. 클라이언트는 임의의 순서로 리소스를 요청할 수 있으며 모든 요청은 무상태이거나 다른 요청과 분리됩니다. 이 REST API 설계 제약 조건은 서버가 매번 요청을 완전히 이해해서 이행할 수 있음을 의미합니다. 

    > 클라이언트와 서버 간의 통신은 각 요청이 서로 독립적이며 상태를 가지지 않아야 합니다. 클라이언트의 모든 필요한 정보는 요청 내에 포함되어야 하며 서버는 요청에 대한 응답을 통해 상태를 전달합니다.


3. 캐시 가능

    WWW 처럼 클라이언트는 응답을 캐시할 수 있습니다. 응답은 명시적 또는 암묵적으로 캐시 가능 여부를 정의하여 클라이언트가 추가요청에 대해 재사용이 가능하지만, 오래되거나 적절하지 못하면 재사용하는 것을 방지해야한다. 


4. 클라이언트-서버

    일관된 인터페이스는 클라이언트와 서버를 분리합니다. 역활의 분리를 통해 클라이언트는 데이터 저장에 대해 걱정하지 않고, 서버 내부에 유지되므로 클라이언트 코드의 이식성이 향상된다고 합니다. 서버는 더 이상 사용자 인터페이스나 사용자 상태에 대한 관심이 없어져 서버가 단순하고 확장 가능해집니다. 인터페이스가 변경되지 않는 이상 서버와 클라이언트는 교체 및 독립적으로 개발할 수 있습니다.

5. 계층 구조화 시스템

    일반적으로 클라이언트는 직접적으로 최종 서버에 연결되었는지 아니면 중계 서버에 연결되었는지 판단할 수 없습니다. 계층의 구조화를 통해 중계서버에 공유 캐시,보안, 등을 제공함으로써 시스템 확장성을 향상시킬 수 있습니다. 계층은 또한 보안 정책을 강화할 수 있습니다.

    >계층화된 시스템 아키텍처에서 클라이언트는 클라이언트와 서버 사이의 다른 승인된 중개자에게 연결할 수 있으며 여전히 서버로부터도 응답을 받습니다. 서버는 요청을 다른 서버로 전달할 수도 있습니다. 클라이언트 요청을 이행하기 위해 함께 작동하는 보안, 애플리케이션 및 비즈니스 로직과 같은 여러 계층으로 여러 서버에서 실행되도록 RESTful 웹 서비스를 설계할 수 있습니다. 이러한 계층은 클라이언트에 보이지 않는 상태로 유지됩니다.

